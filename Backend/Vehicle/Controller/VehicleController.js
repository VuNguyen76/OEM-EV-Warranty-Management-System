const createVehicleModel = require('../Model/Vehicle');
const responseHelper = require('../../shared/utils/responseHelper');
const queryHelper = require('../../shared/utils/queryHelper');
const redisService = require('../../shared/services/RedisService');
const { getCached, setCached, clearCachePatterns } = require('../../shared/services/CacheHelper');
const { normalizeVIN, isValidVINFormat } = require('../../shared/services/VehicleServiceHelper');

let Vehicle = null;

const initializeModels = () => {
    if (!Vehicle) {
        Vehicle = createVehicleModel();
    }
};

/**
 * UC1: ƒêƒÉng k√Ω xe theo VIN
 * - Nh·∫≠p VIN v√† th√¥ng tin ch·ªß xe
 * - T·ª± ƒë·ªông l·∫•y th√¥ng tin model t·ª´ Manufacturing
 * - L∆∞u v√†o Vehicle DB
 */
const registerVehicle = async (req, res) => {
    try {
        const {
            vin,
            // ‚úÖ TH√îNG TIN KH√ÅCH H√ÄNG (do kh√°ch h√†ng cung c·∫•p cho nh√¢n vi√™n d·ªãch v·ª•)
            ownerName,
            ownerPhone,
            ownerEmail,
            ownerAddress,
            purchaseDate,
            purchasePrice,
            dealerName,
            // ‚úÖ SERVICE CENTER INFORMATION (from authenticated staff user)
            serviceCenterId, // Optional - can use from req.user if not provided
            notes
        } = req.body;

        if (!vin || !ownerName || !ownerPhone || !ownerAddress || !purchaseDate) {
            return responseHelper.error(res, "Thi·∫øu th√¥ng tin b·∫Øt bu·ªôc: VIN, t√™n ch·ªß xe, s·ªë ƒëi·ªán tho·∫°i, ƒë·ªãa ch·ªâ, ng√†y mua", 400);
        }

        // ‚úÖ SERVICE CENTER ID: Use from request body or authenticated user
        const actualServiceCenterId = serviceCenterId || req.user.serviceCenterId || req.user.sub;
        if (!actualServiceCenterId) {
            return responseHelper.error(res, "Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c Service Center. Vui l√≤ng li√™n h·ªá qu·∫£n tr·ªã vi√™n", 400);
        }

        // Validate purchase date
        const purchaseDateObj = new Date(purchaseDate);
        if (purchaseDateObj > new Date()) {
            return responseHelper.error(res, "Ng√†y mua kh√¥ng th·ªÉ trong t∆∞∆°ng lai", 400);
        }

        if (!isValidVINFormat(vin)) {
            return responseHelper.error(res, "VIN kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng (ph·∫£i 17 k√Ω t·ª±, kh√¥ng ch·ª©a I, O, Q)", 400);
        }

        initializeModels();

        const VINLookupService = require('../services/VINLookupService');

        console.log(`üîç Validating and looking up VIN: ${vin}`);
        const authToken = req.headers.authorization?.replace('Bearer ', '');
        const vehicleInfo = await VINLookupService.validateAndLookupVIN(vin, authToken);
        console.log(`‚úÖ VIN lookup successful:`, {
            vin: vehicleInfo.vin,
            modelName: vehicleInfo.modelName,
            manufacturer: vehicleInfo.manufacturer,
            year: vehicleInfo.year,
            qualityStatus: vehicleInfo.qualityStatus
        });

        const existingVehicle = await VINLookupService.checkVINRegistration(vin);
        if (existingVehicle) {
            return responseHelper.error(res, "VIN n√†y ƒë√£ ƒë∆∞·ª£c ƒëƒÉng k√Ω", 400);
        }

        const serviceCenterInfo = await VINLookupService.getServiceCenterInfo(actualServiceCenterId);
        console.log(`‚úÖ Service center validated:`, serviceCenterInfo);
        const vehicle = new Vehicle({
            vin: vehicleInfo.vin,
            modelId: vehicleInfo.modelId,
            modelName: vehicleInfo.modelName,
            modelCode: vehicleInfo.modelCode,
            manufacturer: vehicleInfo.manufacturer,
            year: vehicleInfo.year,
            category: vehicleInfo.category,
            color: vehicleInfo.color,
            productionDate: vehicleInfo.productionDate,
            productionBatch: vehicleInfo.productionBatch,
            productionLocation: vehicleInfo.productionLocation,
            plantCode: vehicleInfo.plantCode,
            batteryCapacity: vehicleInfo.batteryCapacity,
            motorPower: vehicleInfo.motorPower,
            variant: vehicleInfo.variant,
            vehicleWarrantyMonths: vehicleInfo.vehicleWarrantyMonths,
            ownerName,
            ownerPhone,
            ownerEmail,
            ownerAddress,
            purchaseDate: purchaseDateObj,
            purchasePrice: purchasePrice || null,
            dealerName: dealerName || null,
            serviceCenterId: serviceCenterInfo.id,
            serviceCenterName: serviceCenterInfo.name,
            serviceCenterCode: serviceCenterInfo.code,
            // ‚úÖ TH√îNG TIN NH√ÇN VI√äN (ng∆∞·ªùi ƒëƒÉng k√Ω xe thay m·∫∑t kh√°ch h√†ng)
            registeredBy: req.user.email,
            registeredByRole: req.user.role,
            createdBy: req.user.email,
            notes,
            vinValidatedAt: vehicleInfo.validatedAt,
            qualityStatus: vehicleInfo.qualityStatus
        });

        await vehicle.save();
        await clearCachePatterns(["vehicles:*"]);

        console.log(`‚úÖ Vehicle registered successfully: ${vehicle.vin}`);

        // ‚úÖ T·ª∞ ƒê·ªòNG K√çCH HO·∫†T B·∫¢O H√ÄNH sau khi ƒëƒÉng k√Ω xe th√†nh c√¥ng
        let warrantyActivation = null;
        try {
            const WarrantyActivationModel = require('../../Warranty/Model/WarrantyActivation');
            const WarrantyActivation = WarrantyActivationModel();

            // Calculate warranty dates from purchase date
            const warrantyStartDate = purchaseDateObj;
            const warrantyEndDate = new Date(warrantyStartDate);
            warrantyEndDate.setMonth(warrantyEndDate.getMonth() + vehicleInfo.vehicleWarrantyMonths);

            warrantyActivation = new WarrantyActivation({
                vin: vehicleInfo.vin,
                warrantyStartDate,
                warrantyEndDate,
                warrantyMonths: vehicleInfo.vehicleWarrantyMonths,
                warrantySource: 'model',
                warrantyStatus: 'active',
                serviceCenterId: serviceCenterInfo.id,
                serviceCenterName: serviceCenterInfo.name,
                serviceCenterCode: serviceCenterInfo.code,
                // ‚úÖ TH√îNG TIN NH√ÇN VI√äN (ng∆∞·ªùi k√≠ch ho·∫°t b·∫£o h√†nh thay m·∫∑t kh√°ch h√†ng)
                activatedBy: req.user.email,
                activatedByRole: req.user.role,
                activatedDate: new Date(),
                notes: `Auto-activated during vehicle registration by ${req.user.email}`,
                createdBy: req.user.email,
                createdByRole: req.user.role
            });

            await warrantyActivation.save();
            console.log(`‚úÖ Warranty auto-activated for VIN: ${vehicle.vin}`);

        } catch (warrantyError) {
            console.error('‚ö†Ô∏è Warning: Failed to auto-activate warranty:', warrantyError.message);
            // Kh√¥ng l√†m th·∫•t b·∫°i ƒëƒÉng k√Ω xe n·∫øu k√≠ch ho·∫°t b·∫£o h√†nh th·∫•t b·∫°i
        }

        return responseHelper.success(res, {
            vehicle: {
                id: vehicle._id,
                vin: vehicle.vin,
                modelName: vehicle.modelName,
                manufacturer: vehicle.manufacturer,
                year: vehicle.year,
                ownerName: vehicle.ownerName,
                purchaseDate: vehicle.purchaseDate,
                serviceCenterName: vehicle.serviceCenterName,
                status: vehicle.status,
                qualityStatus: vehicle.qualityStatus
            },
            warranty: warrantyActivation ? {
                id: warrantyActivation._id,
                warrantyStatus: warrantyActivation.warrantyStatus,
                warrantyStartDate: warrantyActivation.warrantyStartDate,
                warrantyEndDate: warrantyActivation.warrantyEndDate,
                warrantyMonths: warrantyActivation.warrantyMonths,
                remainingDays: warrantyActivation.remainingDays
            } : null
        }, warrantyActivation ?
            `ƒêƒÉng k√Ω xe cho kh√°ch h√†ng ${ownerName} v√† k√≠ch ho·∫°t b·∫£o h√†nh th√†nh c√¥ng` :
            `ƒêƒÉng k√Ω xe cho kh√°ch h√†ng ${ownerName} th√†nh c√¥ng (b·∫£o h√†nh ch∆∞a k√≠ch ho·∫°t)`, 201);
    } catch (error) {
        console.error('‚ùå Error in registerVehicle:', error);
        return responseHelper.error(res, `L·ªói khi ƒëƒÉng k√Ω xe: ${error.message}`, 500);
    }
};

/**
 * L·∫•y th√¥ng tin xe theo VIN
 */
const getVehicleByVIN = async (req, res) => {
    try {
        const { vin } = req.params;
        const cacheKey = `vehicles:vin:${normalizeVIN(vin)}`;

        initializeModels();

        const cachedData = await getCached(cacheKey);
        if (cachedData) {
            return responseHelper.success(res, cachedData, "L·∫•y th√¥ng tin xe th√†nh c√¥ng (t·ª´ cache)");
        }

        const vehicle = await Vehicle.findByVIN(vin);
        if (!vehicle) {
            return responseHelper.error(res, "Kh√¥ng t√¨m th·∫•y xe v·ªõi VIN n√†y", 404);
        }

        await setCached(cacheKey, vehicle, 600);

        return responseHelper.success(res, vehicle, "L·∫•y th√¥ng tin xe th√†nh c√¥ng");
    } catch (error) {
        return responseHelper.error(res, "L·ªói khi l·∫•y th√¥ng tin xe", 500);
    }
};

const getAllVehicles = async (req, res) => {
    try {
        const { page = 1, limit = 10, search, status, serviceCenterCode } = req.query;
        const cacheKey = `vehicles:all:${page}:${limit}:${search || ''}:${status || ''}:${serviceCenterCode || ''}`;

        initializeModels();

        const cachedData = await getCached(cacheKey);
        if (cachedData) {
            return responseHelper.success(res, cachedData, "L·∫•y danh s√°ch xe th√†nh c√¥ng (t·ª´ cache)");
        }

        let query = {};

        if (search) {
            query = queryHelper.buildSearchQuery(search, ['vin', 'ownerName', 'ownerPhone', 'modelName']);
        }

        if (status) {
            query.status = status;
        }

        if (serviceCenterCode) {
            query.serviceCenterCode = serviceCenterCode.toUpperCase();
        }

        const { skip, limitNum } = queryHelper.parsePagination({ page, limit });

        const vehicles = await Vehicle.find(query)
            .select("vin modelName modelCode manufacturer year color ownerName ownerPhone serviceCenterName status registrationDate")
            .sort({ registrationDate: -1 })
            .skip(skip)
            .limit(limitNum);

        const total = await Vehicle.countDocuments(query);
        const pagination = responseHelper.createPagination(page, limit, total);

        const result = { vehicles, pagination };

        await setCached(cacheKey, result, 300);

        return responseHelper.success(res, result, "L·∫•y danh s√°ch xe th√†nh c√¥ng");
    } catch (error) {
        return responseHelper.error(res, "L·ªói khi l·∫•y danh s√°ch xe", 500);
    }
};

const updateVehicle = async (req, res) => {
    try {
        const { id } = req.params;
        const updateData = req.body;

        initializeModels();

        delete updateData.vin;
        delete updateData.createdBy;
        delete updateData.registeredBy;

        updateData.updatedBy = req.user.email;

        const vehicle = await Vehicle.findByIdAndUpdate(id, updateData, { new: true });
        if (!vehicle) {
            return responseHelper.error(res, "Kh√¥ng t√¨m th·∫•y xe", 404);
        }

        await clearCachePatterns(["vehicles:*"]);

        return responseHelper.success(res, vehicle, "C·∫≠p nh·∫≠t th√¥ng tin xe th√†nh c√¥ng");
    } catch (error) {
        return responseHelper.error(res, "L·ªói khi c·∫≠p nh·∫≠t xe", 500);
    }
};

const searchVehicles = async (req, res) => {
    try {
        const { q, type = 'all', page = 1, limit = 10 } = req.query;

        if (!q) {
            return responseHelper.error(res, "Thi·∫øu t·ª´ kh√≥a t√¨m ki·∫øm", 400);
        }

        initializeModels();

        let query = {};

        switch (type) {
            case 'vin':
                query.vin = { $regex: q, $options: 'i' };
                break;
            case 'owner':
                query.$or = [
                    { ownerName: { $regex: q, $options: 'i' } },
                    { ownerPhone: { $regex: q, $options: 'i' } }
                ];
                break;
            case 'model':
                query.$or = [
                    { modelName: { $regex: q, $options: 'i' } },
                    { modelCode: { $regex: q, $options: 'i' } }
                ];
                break;
            default:
                query = queryHelper.buildSearchQuery(q, ['vin', 'ownerName', 'ownerPhone', 'modelName', 'modelCode']);
        }

        const { skip, limitNum } = queryHelper.parsePagination({ page, limit });

        const vehicles = await Vehicle.find(query)
            .select("vin modelName modelCode manufacturer year color ownerName ownerPhone serviceCenterName status")
            .sort({ registrationDate: -1 })
            .skip(skip)
            .limit(limitNum);

        const total = await Vehicle.countDocuments(query);
        const pagination = responseHelper.createPagination(page, limit, total);

        return responseHelper.success(res, { vehicles, pagination }, "T√¨m ki·∫øm xe th√†nh c√¥ng");
    } catch (error) {
        return responseHelper.error(res, "L·ªói khi t√¨m ki·∫øm xe", 500);
    }
};

const getVehicleStatistics = async (req, res) => {
    try {
        const cacheKey = 'vehicle_statistics';

        const cachedStats = await getCached(cacheKey);
        if (cachedStats) {
            return responseHelper.success(res, cachedStats, 'Th·ªëng k√™ xe (t·ª´ cache)');
        }

        const totalVehicles = await Vehicle.countDocuments();
        const activeVehicles = await Vehicle.countDocuments({ status: 'active' });
        const inactiveVehicles = await Vehicle.countDocuments({ status: 'inactive' });

        const brandStats = await Vehicle.aggregate([
            { $group: { _id: '$manufacturer', count: { $sum: 1 } } },
            { $sort: { count: -1 } }
        ]);

        const yearStats = await Vehicle.aggregate([
            { $group: { _id: '$year', count: { $sum: 1 } } },
            { $sort: { _id: -1 } }
        ]);

        const statistics = {
            totalVehicles,
            activeVehicles,
            inactiveVehicles,
            brandDistribution: brandStats,
            yearDistribution: yearStats,
            lastUpdated: new Date()
        };

        await setCached(cacheKey, statistics, 300);

        responseHelper.success(res, statistics, 'L·∫•y th·ªëng k√™ xe th√†nh c√¥ng');
    } catch (error) {
        responseHelper.error(res, 'L·ªói khi l·∫•y th·ªëng k√™ xe', 500);
    }
};

module.exports = {
    initializeModels,
    registerVehicle,
    getVehicleByVIN,
    getAllVehicles,
    updateVehicle,
    searchVehicles,
    getVehicleStatistics
};